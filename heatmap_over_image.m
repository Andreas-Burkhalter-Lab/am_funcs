%%%% overlay heatmap of a variable on the time-averaged image of cells
%
%    heatmap_over_image(roitable, roitable_rows, var_to_heatmap, filetable, filetable_row)
%
% -roitable and filetable are generated by analyze_multi_planes.m
% -tuning_stats can be used to generate input to roitable_rows (use ops.meets_criteria)
% -data for heatmap will be plotted from roitable...
%       ... time-averaged image and patches image will be loaded from tuningdat struct
% -the session must have undergone alignment with an m2 patches image
%%%% updated 2020/1/22 on thermaltake

function figvars = heatmap_over_image(roitable, roitable_rows, var_to_heatmap, filetable, ops)

%% parameters
ops = vardefault('ops',struct);
% ops.background_image_source = field_default(ops,'background_image_source','time_averaged'); % time averaged gcamp from recording
% ops.background_image_source = field_default(ops,'background_image_source','m2'); % m2 image used to find patches
% ops.background_image_source = field_default(ops,'background_image_source','m2_blurred'); % blurred m2 image used to find patches
ops.background_image_source = field_default(ops,'background_image_source','quant_levels_img'); %%% m2 quantiles
% ops.background_image_source = field_default(ops,'background_image_source','patchimage'); %%% patch areas filled in
% ops.background_image_source = field_default(ops,'background_image_source','patch_bounds'); %%% patch borders
        
ops.logval = field_default(ops,'logval',0); % if true, take log of specified parameter value
% ops.colormap_for_paramvals = field_default(ops,'colormap_for_paramvals',parula);
ops.colormap_for_paramvals = field_default(ops,'colormap_for_paramvals',jet);
% ops.colormap_for_paramvals = field_default(ops,'colormap_for_paramvals',cool);
ops.colorbar_n_ticks = field_default(ops,'colorbar_n_ticks',5); 
ops.save_image = field_default(ops,'save_image',0); 
    ops.resolution_dpi = field_default(ops,'resolution_dpi',500);
    ops.savename = field_default(ops,'savename','heatmap_over_image_fig');

    %% load data
if length(unique(roitable.sub(roitable_rows))) > 1 %%% check that all rois are from the same subject
    error('Attempting to plot ROIs from different subjects on same heatmap')
end
if length(unique(roitable.day(roitable_rows))) > 1 %%% check that all rois are from the same session
    error('Attempting to plot ROIs from different sessions on same heatmap')
end
this_sub = roitable.sub(find(roitable_rows,1));
this_day = roitable.day(find(roitable_rows,1));
filetable_row = find(filetable.sub==this_sub & strcmp(filetable.day,this_day), 1); %%% get filetable row that matches the rois
load([filetable.directory{filetable_row}, filesep, filetable.tuning_file{filetable_row}]) %%% should load 'tuningdat' struct

%% plotting
switch ops.background_image_source
    case 'time_averaged'
        background_image = tuningdat.reg_struct.movingimage_warped; % show the time-averaged image after it's been aligned to the M2 image
    case 'm2'
        background_image = tuningdat.patchdata.im;
    case 'm2_blurred'
        background_image = tuningdat.patchdata.imroiblurred; 
    case 'quant_levels_img'
        background_image = tuningdat.patchdata.quant_levels_img; 
    case 'patchimage'
        background_image = tuningdat.patchdata.patchimage;
    case 'patch_bounds'
        background_image = tuningdat.patchdata.bnds_patches;
end

%%% show background image
figure
figvars.ax1 = axes;
imagesc(background_image)

cc = repmat(linspace(0,1,64)',1,3); % bw
cc = cc.^2;
set(gca,'Colormap',cc)

%%% get roi values
if islogical(roitable_rows)
    roitable_rows = find(roitable_rows);
end
allvals = roitable{roitable_rows,var_to_heatmap};
if ops.logval
    if any(allvals < 0)
        fprintf('Some raw values to plot are negative, not converting to log values\n')
    else
        allvals = log(allvals);
    end
end
minval = min(allvals);
maxval = max(allvals);
normedvals = [allvals - minval] ./ [maxval-minval];

%%% plot roi values
nrois = length(roitable_rows);
view(2)
figvars.ax2 = axes; 
for iroi = 1:nrois
    clear ii jj
    this_roi_row = roitable_rows(iroi); 
    [ii jj] = find(roitable.roi_image_reg{this_roi_row});
    val_in_cmap = ops.colormap_for_paramvals( round(normedvals(iroi)*63)+1,: );
    scatter(figvars.ax2,jj,ii,[],repmat(val_in_cmap,length(ii),1),'.')
    hold on
end
set(gca,'YDir','reverse'); % y coords start reversed relative to background image
hold off

linkaxes([figvars.ax1,figvars.ax2])
set(gca,'XTick',[])
set(gca,'YTick',[])
figvars.ax2.Visible = 'off';
figvars.ax2.Colormap = ops.colormap_for_paramvals; %%% set colormap so we can create colorbar

%%%% adding colorbar to axis 1 incorrectly shifts axis 1 relative to axis 2
figvars.cbar2 = colorbar(figvars.ax2,'Position',[.9 .11 .035 .815]);
    figvars.cbar2.TickLabels = num2str(linspace(minval,maxval,ops.colorbar_n_ticks)');
    figvars.cbar2.Ticks = linspace(0,1,ops.colorbar_n_ticks);

%%% save image
if ops.save_image
    print(gcf, [ops.savename,'.tif'], '-dtiffn',['-r',num2str(ops.resolution_dpi)])
end
    