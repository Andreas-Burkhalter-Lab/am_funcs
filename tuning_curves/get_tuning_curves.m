%%%% get_tuning_curves for sfreq, tfreq, orientation, diam receptive field mapping
% res = get_tuning_curves(...
%     dff_file, triggertiming_file, stimdata_file, scopetiming_file, regops_file, pupil_data_file, patchdata_file, patch_reg_file, pars)
% 
% dff_files = dF/F data for each plane generated by convertSuite2Pdata.m (not _proc files from new_main)   
% triggertiming_file = behavioral + microscope timing file
% stimdata_file = data on stimulus parameters for each trial
% scopetiming_file = file listing start and stop points of scope within abf file generated with getAbfStartStop.m   
% regops_file = file generated during registration
% pupil_data_file = matfile with pupil data
% patchdata_file (optional, must also include patchdata_reg_file) = patch data for determining patch locations of ROIs
% patch_reg_file = reg file for aligning locations of ROIs with patches image
% 
%%%%% last updated 2020/1/29 on thermaltake

function res = get_tuning_curves(...
    dff_file, triggertiming_file, stimdata_file, scopetiming_file, regops_file, pupil_data_file, patchdata_file, patch_reg_file, pars)

pars.fit_tuning_functions = field_default(pars,'fit_tuning_functions',1); % fit tuning functions (takes longer) rather than just getting anovaP
% look in this time window in seconds for activity to compare stimulus-evoked and baseline activity 
pars.responsivity_window_poststim_sec = field_default(pars, 'responsivity_window_poststim_sec', [0.1 2]) ; % [window start, window stop]
% pars.responsivity_window_poststim_sec = field_default(pars, 'responsivity_window_poststim_sec', [0 4]) ; % [window start, window stop]
pars.baseline_window_sec = field_default(pars, 'baseline_window_sec', 1); % use this number of seconds before stim onset for determining baseline
pars.locomotion_threshold_mps = field_default(pars, 'locomotion_threshold_mps', 0.001); %% threshold speed in meters/s for considering locomotion to be occurring (.001 in Pakan 2016)
pars.stimpars_to_analyze = field_default(pars, 'stimpars_to_analyze', {'sf','tf','orient','diam'});
pars.all_scopetiming_files = field_default(pars, 'all_scopetiming_files', {}); % list of other sub-sessions in a concatenated run, used to eliminate extra scope pulses in multi-plane sessions
pars.dff_downsample_factor = field_default(pars,'dff_downsample_factor',1); % keep only one of every [dff_downsample_factor] dff values; don't use deleted values for averaging
pars.skip_all_checks = field_default(pars,'skip_all_checks',0); %%% if true, skip all checks requiring user input to proceed - do not turn on for first-pass analysis

regops_file = vardefault('regops_file',[]);
load_f_behavior_stim_data() 
responsivity_window_poststim_us = pars.responsivity_window_poststim_sec .* 1e6; % convert from s to microseconds
responsivity_window_poststim_scans = round(responsivity_window_poststim_us ./ trig_sampling_interval_us); 
baseline_window_us = pars.baseline_window_sec * 1e6;
baseline_window_scans = baseline_window_us / trig_sampling_interval_us; 

% set response and baseline timing
stimpar_sets.rspv_window_start = stimpar_sets.stim_onset + responsivity_window_poststim_scans(1); % which scan to start the responsivity window on
stimpar_sets.rspv_window_end = stimpar_sets.stim_onset + responsivity_window_poststim_scans(2); % which scan to end the responsivity window on
stimpar_sets.baseline_window_start = stimpar_sets.stim_onset - baseline_window_scans; % which scan to start baseline window on

%% get info for each time point
get_f_behavior_stim()
[res, stimpar_sets] = removeBadFrames(res, stimpar_sets, scope_events, scopetiming, stimdur_scans, baseline_window_scans); % remove bad frames if badframes excel file is present


%% find stim events
ntrials = height(stimpar_sets); % update in case trials were removed
dFF_matrix = NaN(height(stimpar_sets),size(dff_data.dff,2));
dffcell = cell(size(dFF_matrix));
nancol = NaN(ntrials,1);
stimpar_sets = [stimpar_sets table(nancol,nancol,nancol,dFF_matrix,dFF_matrix,dFF_matrix,dffcell,dffcell,dffcell,'VariableNames',...
    {'locm_forw_mps','locm_yaw_mps','locm_total_mps','dff_during_stim','dff_during_rspv_window','dff_prestim','timecourse_prestim','timecourse_stim','timecourse_poststim'})];
% for each stim trial, get corresponding scope events and locomotion data
if ~isempty(pupil_data_file)
    stimpar_sets.pupil_keeptrial = false(ntrials,1);
end
for itrial = 1:ntrials
    % F timecourse from end of preceding trial to beginning of next trial
    sevents_in_range_stim = find( scope_events.onset>stimpar_sets.stim_onset(itrial) & scope_events.onset<[stimpar_sets.stim_onset(itrial)+stimdur_scans] );
%     sevents_in_range_stim = sevents_in_range_stim(1:end-1); % last image duration will be cut off by stim ending... commented out because there may be only one scope event/trial at low acquisition rate
    stim_first_scan = min(sevents_in_range_stim); % row index in scope_events
    sevents_in_range_stim_fixed_duration = stim_first_scan : stim_first_scan+stimdur_scope_events-1; % stim events in this trial using a fixed stim duration
    stim_last_scan = max(sevents_in_range_stim); % row index in scope_events
    % use a fixed number of scans for prestim, stim, and poststim periods to make peristimulus timecourse plots consistent
    sevents_in_range_prestim = stim_first_scan-isi_scope_events : stim_first_scan-1; 
    sevents_in_range_poststim = stim_last_scan+1 : stim_last_scan+isi_scope_events; % scope events during isi between this trial and next trial
    if max(sevents_in_range_poststim) <= size(dff_data.dff,1) %%% if this trial is not cut off by the end of the recording, process normally 
        stimpar_sets.timecourse_prestim(itrial,:) = num2cell(scope_events.dff(sevents_in_range_prestim,:), 1);
        stimpar_sets.timecourse_stim(itrial,:) = num2cell(scope_events.dff(sevents_in_range_stim_fixed_duration,:), 1);
        stimpar_sets.timecourse_poststim(itrial,:) = num2cell(scope_events.dff(sevents_in_range_poststim,:), 1);
    else %%% if this trial is cut off by the end of the recording, fill with nans
        stimpar_sets.timecourse_prestim(itrial,:) = repmat({NaN(size(stimpar_sets.timecourse_prestim{1,1}))}, 1, size(stimpar_sets.timecourse_prestim,2));
        stimpar_sets.timecourse_stim(itrial,:) = repmat({NaN(size(stimpar_sets.timecourse_stim{1,1}))}, 1, size(stimpar_sets.timecourse_stim,2));
        stimpar_sets.timecourse_poststim(itrial,:) = repmat({NaN(size(stimpar_sets.timecourse_poststim{1,1}))}, 1, size(stimpar_sets.timecourse_poststim,2));
    end
    stimpar_sets.dff_during_stim(itrial,:) = mean(scope_events.dff(sevents_in_range_stim,:),1);     % F during stim
    stimpar_sets.locm_forw_mps(itrial) = mean(scope_events.locomotion_forw_mpersec(sevents_in_range_stim),1);
    stimpar_sets.locm_yaw_mps(itrial) = mean(scope_events.locomotion_yaw_mpersec(sevents_in_range_stim),1); %%% will be nan for 4th floor data, no yaw motion
    % F during stim 'responsivity window'
    sevents_in_range_responsivity = find(scope_events.onset > stimpar_sets.rspv_window_start(itrial) & scope_events.onset < stimpar_sets.rspv_window_end(itrial));
    stimpar_sets.dff_during_rspv_window(itrial,:) = mean(scope_events.dff(sevents_in_range_responsivity,:),1);
    % F during prestim 'baseline window'
    sevents_in_range_baseline = find(scope_events.onset > stimpar_sets.baseline_window_start(itrial) & scope_events.onset < stimpar_sets.stim_onset(itrial));
    sevents_in_range_baseline = sevents_in_range_baseline(1:end-1); % last image duration will be interrupted by stim onset 
    stimpar_sets.dff_prestim(itrial,:) = mean(scope_events.dff(sevents_in_range_baseline,:),1);
    % eliminate trials based on pupil data
    if ~isempty(pupil_data_file) && all(scope_events.pupil_keepframe(sevents_in_range_stim)) %%% if frames that occurred during this trial need to be discarded based on pupil data
        stimpar_sets.pupil_keeptrial(itrial) = true; % don't discard the trial
    end
end
stimpar_sets.locm_total_mps = sqrt(nansum([stimpar_sets.locm_forw_mps.^2, stimpar_sets.locm_yaw_mps.^2], 2)); % note - forward and backward speeds are considered equivalent by this computation
if ~isempty(pupil_data_file)
    stimpar_sets(~stimpar_sets.pupil_keeptrial,:) = []; % eliminate trials based on pupil data
    stimpar_sets.pupil_keeptrial = [];
end
ntrials = height(stimpar_sets); % update ntrials

%% tuning curves
    % not implemented yet: check for OFF responses?

% get tuning curves for each stim param and each roi
nrois = size(dff_data.dff,2);
switch stimpars.experiment_type
    case 'sf_tf_orient_diam'
        tuning_curves_loop(); 
        % get the locomotion modulation index described in Pakan et al. 2016 - Behavioral-state modulation of inhibition is context-dependent and cell type specific in mouse visual cortex
        res.tuning = pakan_locomotion_modulation(res.tuning, scope_events, scopetiming, pars); 
    case 'rf_mapping'
        rf_mapping_analysis();
end
%%% clear full response timecourse data to shrink file size
stimpar_sets.timecourse_prestim = []; 
stimpar_sets.timecourse_stim = []; 
stimpar_sets.timecourse_poststim = []; 

%% % determine whether or not cell was responsive to stimuli
responsivity = table(false(nrois,1),NaN(nrois,1),cell(nrois,1),cell(nrois,1),cell(nrois,1),'VariableNames',{'rspv','rspv_pval','preftrials','F_duringwindow','dff_prestim'});
try
    for iroi = 1:nrois
        [~,m] = max(res.tuning.sf_trials{iroi}.resp_mean);
        prefsf = res.tuning.sf_trials{iroi}.sf(m);
        [~,m] = max(res.tuning.tf_trials{iroi}.resp_mean);
        preftf = res.tuning.tf_trials{iroi}.tf(m);
        preftrials = find(stimpar_sets.sfreq==prefsf | stimpar_sets.tfreq==preftf); % find trials when cell saw preferred stimuli
        responsivity.dff_prestim{iroi} = stimpar_sets.dff_prestim(preftrials,iroi);
        responsivity.F_duringwindow{iroi} = stimpar_sets.dff_during_rspv_window(preftrials,iroi);
        [responsivity.rspv(iroi), responsivity.rspv_pval(iroi)] = ttest(responsivity.dff_prestim{iroi}, responsivity.F_duringwindow{iroi});
        responsivity.preftrials{iroi} = preftrials;
    end
    res.responsivity = responsivity;
    res.tuning.rspv = responsivity.rspv;
    res.tuning.rspv_pval = responsivity.rspv_pval;
end

%% get patch location if patch data is given
if exist('patchdata_file', 'var') && exist('patch_reg_file', 'var') && ~all(isnan(patchdata_file)) && ~isempty(patchdata_file)
    res = get_roi_patch_location(res, patchdata_file, patch_reg_file);
end

%% get locomotion data for each trial........ sf tf orient only
locm_trials = struct;
for thispar = pars.stimpars_to_analyze
    do_analysis = 0; % default
    thispar = thispar{:};
    initialize_stim_parameter(); 
    if do_analysis
        locm_trials.(thispar) = table(stimparvals,NaN(nparvals,stimpars.repetitions),NaN(nparvals,stimpars.repetitions),...
            'VariableNames',{           thispar,    'locm_forw_mps',                    'locm_total_mps'});
        for indpar = 1:nparvals % get locomotion speeds
            match = find(stimpar_sets{:,par_sets_varname}==stimparvals(indpar) & otherparsfixed);
            locm_trials.(thispar).locm_forw_mps(indpar,1:length(match)) = [stimpar_sets.locm_forw_mps(match)]';
            locm_trials.(thispar).locm_total_mps(indpar,1:length(match)) = [stimpar_sets.locm_total_mps(match)]';
        end 
    end
end

%% output results
res.scope_events = scope_events; %%% scope events from the ENTIRE session, not just the portion of the session we analyzed in this function
res.pars = pars;
res.stimpar_sets = stimpar_sets;
res.locm_trials = locm_trials;
res.triggertiming_file = triggertiming_file;
res.dff_file = dff_file;
res.scopetiming_file = scopetiming_file;
res.stimdata_file = stimdata_file;
        