function [intensities tags] = calc_stack_roi_inten(basename, roiDefFile, options)
% calc_stack_roi_inten takes roi definitions within stack space, created by stack_roi,
% and calculates the mean pixel intensity within each of those regions over time. The
% output is an RxS matrix, where R is the # of rois and S is the # of stacks
% in the experiment.
% Syntax:
%   intensities = calc_stack_roi_inten(basename, roiDefFile)
%   intensities = calc_stack_roi_inten(basename, roiDefFile, options)
% where:
%   basename is the original basic filename from the imagine experimental
%             data (also the header name), this information can either be passed as a
%             primary string (e.g. '2007-07-07-7') or as a named variable that contains this string.
%             BTW:  the header file from the original data should automatically be saved
%             as a .mat or .imagine file into the parent directory for this job by
%             the previous processing function (registration, etc.). If not, you should do this.
%             NOTE: if the previous processing function modified the shape
%             of the data (e.g. dropped the first and last stacks) the
%             copied header needs to be edited to reflect this (you may need to check that
%             this is so if the program barfs at you).
%   roiDefFile is the name of the roi definition file created by stack_roi
%   options is a structure indicating some of the extra behavior you would
%             or would not like calc_stack_roi_inten to exhibit.
%        .show_stack_progress if set to 1(true) causes an indicator of
%             progress through stacks to be indicated on the command screen.
%             Default is true.
%        .show_roi_progress if set to 1(true) causes an indicator of
%             progress through rois to be indicated on the command screen.
%             Default is false.
%        .save_intensity_file if set to 1(true) causes a copy of the RxS
%             outcome matrix to be save to disk as a .mat file. Default is true.
%        .savedir if provided allows you to indicate a different save to
%             directory that the parent data directory (default is parent
%             dir).  This function can be used to save the output matrix to another
%             directory when you do not have write permissions in the parent data
%             directory.
%        .savefile
%        .gaussian (defaut is true). This is parsed to function
%             'roimeasure'. If true, use gaussian weight (centered at roi, spread as sigmal =r)
%             to caculate the integrated roi intensity from an extended 8r-by-8r square region. 
%             If false, simply caculate the average intensity from the roi region.
%         .bias:  if provided this value is used to adjust the floor of the
%           intensity values, it can be either a scalar value for the
%           camera or a vector (scalar value per stack of length equal to
%           number of stacks).
%
%Copywrite 2006 by Jason Guo & Terrence Holekamp

% Revision History
% Modification 2010/11/2 (Julian P Meeks)
%  added second output variable (tags) to hold "tag" information
%  corresponding to each ROI in "intensities".  This will be of
%  dimensions 1 x size(intensities,1) (or the # of rois)
%  This is to allow straightforward analysis of ROIs spanning multiple
%  stacks.
% Modifications 2011/09/07
%  added to the list of "formats" those generated by roi_by_imflow(i.e. pixel lookup table-based ROIs)
%  added speed increases for pixel-lookup-table ROIs

if(nargin==2)
    options.show_stack_progress=1;
    options.show_roi_progress=0;
    options.save_intensity_file=1;
    options.savedir = cd;
    options.gaussian = 1;
end
if(~isfield(options, 'show_stack_progress'))
    options.show_stack_progress=1;
end
if(~isfield(options, 'show_roi_progress'))
    options.show_roi_progress=0;
end
if(~isfield(options, 'save_intensity_file'))
    options.save_intensity_file=1;
end
if(~isfield(options, 'savedir'))
    options.savedir = cd;
end
if(~isfield(options,'gaussian'))
    options.gaussian = 1;
end
if ~isfield(options, 'savefile')
	  options.savefile = [basename '_roi.intensity'];
end

tt=load(roiDefFile, '-mat');
header=tt.header;
roi_defs=tt.roi_defs;
pixelPerUm=tt.pixelPerUm;
do_tform = 0;
if isfield(tt,'tform_info')
  do_tform = 1;
  tform_info=tt.tform_info;
end
  
stack = stackmm(basename);
stackSize=stack.size;
if isfield(header, 'compound_cam')
  header.nstacks = sum(header.nstacks);
end
if ~isfield(options, 'bias')
    options.bias = [];
else if ~(length(options.bias)==1) && ~(length(options.bias)==header.nstacks);
    warning('bias must be either a scalar or vector of length equal to number of stacks');
    return
    end
end

roi_fmt = convertRoiFormat(roi_defs,stackSize(1:3));

% to warn user when headerFile is not same as header.header_filename
%    and re-read header from headerFile
if(~isequal(basename, header.header_filename))
    warning('input header file may not be same as the header used to define ROIs');
    header=imreadheader(basename);
end

intensities=ones(length(roi_defs), sum(header.nstacks))*inf;

tic;

% ROI-at-once method
% prog  = progress(struct('progress',0,'max',length(roi_fmt),'caption','calc_stack_inten_new: %d %% done','what',...
%	                      'Please wait.  Expect ~1 min per ROI'));
% for i = 1:length(roi_fmt)
% 	flatimg = zeros([size(roi_fmt(i).pixels,1) stackSize(4)]);
% 	flatimg = stack(roi_fmt(i).pixels(:,1),roi_fmt(i).pixels(:,2),roi_fmt(i).pixels(:,3),:);
% 	intensities(i,:) = sum(bsxfun(@times,double(flatimg),roi_fmt(i).weight),1);
% 	prog.progress = i; progress(prog);
% end

% Stack-at-once method
if isnumeric([roi_fmt.label])
	pixids = [roi_fmt.label];
else
	pixids = 1:length(roi_fmt);
end
pix_group = [];
for i = 1:length(roi_fmt)
	pix_group = [pix_group zeros([1 roi_fmt(i).npix])+pixids(i)];
end
prog  = progress(struct('progress',0,'max',stackSize(4),'caption','calc_stack_inten_new: %d %% done','what',...
	                      'Please wait.  Expect ~1 min per ROI'));
for i = 1:stackSize(4)
	W = sparse(pix_group,cat(1,roi_fmt.pixels)',cat(1,roi_fmt.weight),length(roi_fmt),prod(stackSize(1:3)));
	tmp = double(stack(:,:,:,i));
    if length(options.bias)==1,
        tmp = tmp - options.bias;
        tmp(tmp<0)=0;
    else 
        tmp = tmp - options.bias(i);
        tmp(tmp<0)=0;
    end
  intensities(:,i) = W*tmp(:);
	prog.progress = i; progress(prog);
end



prog.progress = -1;
prog = progress(prog); if ishandle(prog.handle); delete(prog.handle); end; clear prog;



tags = cell([1 length(tt.roi_defs)]);
for i = 1:length(tt.roi_defs)
    tags{i} = tt.roi_defs(i).label;
end

toc;

if options.save_intensity_file
    c = cd;
    cd (options.savedir)
    save(options.savefile,'intensities','tags')
    cd(c);
end


function result=convertRoiFormat(roi_def,sz)
if isfield(roi_def,'posInPixel')
	  len = length(roi_def);
    result = struct('type',repmat({'c'},1,len));
    [result.label]=deal(roi_def.label);
    [result.x]=deal(roi_def.posInPixel(1));
    [result.y]=deal(roi_def.posInPixel(2));
    [result.xyradius]=deal(roi_def.xyradiusInPixel);
		% TODO: separate fxn to create "pixels", "weights" categories from circlular/ellipsoid?
elseif isfield(roi_def,'pixels')
  	len = length(roi_def);
	  result = struct('type',repmat({'p'},1,len));
		[result.label] = deal(roi_def.label);
		[result.keep] = deal([]);
		for i = 1:length(roi_def)
			for j = 1:length(roi_def(i).vtxInPixels);
				if ~isempty(roi_def(i).vtxInPixels{j})
					result(i).keep = [result(i).keep j];
					result(i).npix = size(roi_def(i).pixels,1);
					result(i).pixels = sub2ind(sz,roi_def(i).pixels(:,1),roi_def(i).pixels(:,2),roi_def(i).pixels(:,3));
				end
			end
		end
		[result.weight] = deal(roi_def.weight);
elseif isfield(roi_def,'centerInPixels')
    len = length(roi_def);
    result =struct('typel',repmat({'v'},1,len));
    [result.label]=deal(roi_def.label);
    [result.vtxInPixels]=deal(roi_def.vtxInPixels);
    [result.keep] = deal([]);
    for i = 1:length(roi_def)
        for j = 1:length(roi_def(i).vtxInPixels)
            if ~isempty(roi_def(i).vtxInPixels{j})
                result(i).keep = [result(i).keep j];
            end
        end
    end
    %TODO: separate fxn to create "pixels","weights" categories from vertex-defined regions?
else
    error('.roidef file is missing pixel position information\n');
end
% TODO: necessary?

[result.tform]=deal(unit_tform(2));




