function [header,fid] = readheader(file,options)
% READHEADER: Read the header of all types of data files

%%%%%%% AM edited 1/26/15: changed from read_merec_header to read_merec_header_AM 1/26/15
%%% ...required in order to run on recent versions of Matlab

% Syntax:
% [header,fid] = readheader(file) (PREFERRED syntax: see below)
% header = readheader(file)
% header = readheader(...,options)
% where
%    file is a string and is treated as a filename;
%    options is a structure array with the following optional fields:
%      machfmt:  supply the string 'b' or 'l' for big-endian or
%        little-endian legacy data files (not needed except for ancient
%        Harvard header types, where the endian status cannot be
%        determined from the header itself).
%      headertype:  the string 'ai' or 'snip', used in legacy
%        cases in which the header type can't be determined from the data
%        in the header.
% and
%    header is a structure that returns the information in the header;
%    fid is the file identifier.
%
% When called as
%    h = readheader(file),
% the file is closed upon exiting this function, wheras
%   [h,fid] = readheader(file)
% leaves the file open.  File position is set to the beginning of the data
% after reading the header if LFS is not used.  As a bonus, this fid is generated by opening
% the file with the correct endian status, as inferred from data in the
% header.  This allows data to be transferred between PCs (little-endian)
% and Macs (big-endian) transparently.  If you plan on reading data from this
% file, you should open it using this latter form to insure cross-platform
% compatibility.
%
% See also: WRITEHEADER, FOPEN, SUPPORTLEGACYHEADERS.
  
% This function is a gateway function for all types of headers:
%    raw waveforms, envelopes, snippets
% Also handles new as well as old headers
  
  % See if we have to reverse endian status upon opening
  fmt = 'n';  % default native endian status
  if (nargin > 1)
    if isfield(options,'machfmt')
      fmt = options.machfmt;
    end
  end
  % Open the file
  if ~exist(file)
    error(['File ' file ' does not exist!']);
  end
  if (ischar(file))
     if(should_use_lfs(file))
        [fid,message] = openlfs(file);
     else
        [fid,message] = fopen(file,'r',fmt);
     end
    if (fid < 1)
      disp(['Can''t open ' file '; does it exist?'])
      error(message);
    end
  else  % Check to make sure user is not supplying fid
    error(['Do not recognize input ',file]);
  end
  toclose = 1;       % Remember if we should close upon exit
  if (nargout > 1)
    toclose = 0;
  end
    
  options.toclose = toclose;   % By and large, this is here to create the
                               % structure if it doesn't exist already
  
  % Read enough to determine the file type
  if(should_use_lfs(file))
     magicnum = readcharlfs(fid, 1, [0 4], 0);
  else
     magicnum = fread(fid,[1,5],'uchar');
  end
  tStrPos=strmatch(char(magicnum),{'MEREC','ENVEL','SNIPP'});
  if ~isempty(tStrPos)
    % Read MEREC/envelope/snippet header
    switch tStrPos
     case 1
        header=read_merec_header_AM(file);  %% AM changed from read_merec_header to read_merec_header_AM 1/26/15
     case 2
        header=read_envelope_header(file);
     case 3
        header=read_snip_header(file);
    end
    
    if ~toclose
       if(~should_use_lfs(file))
          % Check that the endian status matches the native one; otherwise,
          % close the file and re-open with proper status
          [str,maxsize,endian] = computer;
          if ~strcmp(lower(endian),header.endian)
             fclose(fid);
             [fid,message] = fopen(file,'r',header.endian);
             if (fid < 1)
                error(message);
             end
          end
       end % if, not use lfs
    end % if, not close file
  elseif supportlegacyheaders
    if ~isfield(options,'headertype')
      % Try to figure out from filename how to resolve type
      [pathstr,basename,extension] = fileparts(file);
      if ~isempty(strmatch(extension,{'ssnp','rsnp'}))
        options.headertype = 'snip';
      else
        options.headertype = 'ai';
      end
    end
    header = resolvelegacyheader(fid,magicnum,options);
  else
    if toclose
      fclose(fid);   % Exit cleanly
    end
    error('Header is not of MEREC type');
  end

  % Exit appropriately: either close file, or set file position
  if toclose
     if(should_use_lfs(file))
        closelfs(fid);
     else
        fclose(fid);
     end
  else
     if(~should_use_lfs(file))
        fseek(fid,header.headersize,'bof');
     end
  end
  
  % verify the file length (nScans)
  dirstruct=dir(file);
  nScans=(dirstruct.bytes-header.headersize)/sizeof('uint16')/header.numch;
  if(nScans~=header.nscans && strcmp(char(magicnum),'MEREC'))
     disp('WARNING: file is shorter than what the header claims');
     header.nscans=nScans;
  end
