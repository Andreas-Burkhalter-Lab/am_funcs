%% this version only analyzes recordings from ed han's lab, not the 4th floor scope
%%

%%%% get_tuning_curves for sfreq, tfreq, and orientation
%        res = get_tuning_curves(dff_file, abf_file, stimdata_file, scopetiming_file, regops_file, patchdata_file, patch_reg_file, fit_tuning_functions)
% dff_files = dF/F data for each plane generated by convertSuite2Pdata.m (not _proc files from new_main)   
% abf_file = behavioral + microscope timing file
% stimdata_file = data on stimulus parameters for each trial
% scopetiming_file = file listing start and stop points of scope within abf file generated with getAbfStartStop.m   
% regops_file = file generated during registration
% patchdata_file (optional, must also include patchdata_reg_file) = patch data for determining patch locations of ROIs
% patch_reg_file = reg file for aligning locations of ROIs with patches image
%%%%% last updated 2018/10/25 on thermaltake
function res = get_tuning_curves_hanlab_recordings_only(dff_file, abf_file, stimdata_file, scopetiming_file, regops_file, patchdata_file, patch_reg_file, fit_tuning_functions)

fit_tuning_functions = vardefault('fit_tuning_functions',1); % fit tuning functions (takes longer) rather than just getting anovaP
% look in this time window in seconds for activity to compare stimulus-evoked and baseline activity 
responsivity_window_poststim_sec = [0.1 2] ; % [window start, window stop]
baseline_window_sec = 1; % use this number of seconds before stim onset for determining baseline
% stimpars_to_analyze = {'sf','tf','orient'};
stimpars_to_analyze = {'sf','tf'};

load_f_behavior_stim_data()
responsivity_window_poststim_us = responsivity_window_poststim_sec .* 1e6; % convert from s to microseconds
responsivity_window_poststim_scans = round(responsivity_window_poststim_us ./ abf_sampling_interval_us); 
baseline_window_us = baseline_window_sec * 1e6;
baseline_window_scans = baseline_window_us / abf_sampling_interval_us; 

% set response and baseline timing
par_sets.rspv_window_start = par_sets.stim_onset + responsivity_window_poststim_scans(1); % which scan to start the responsivity window on
par_sets.rspv_window_end = par_sets.stim_onset + responsivity_window_poststim_scans(2); % which scan to end the responsivity window on
par_sets.baseline_window_start = par_sets.stim_onset - baseline_window_scans; % which scan to start baseline window on

% get scope events from abf file
scope_events_allplanes = find_stimchan_events(abf_timepoints(:,scopetiming.scope_chan)');
% delete events found outside the range specified by scope timing file
deleteevents = scope_events_allplanes.onset < scopetiming.scope_start_timepoint | nansum([scope_events_allplanes.onset,scope_events_allplanes.duration],2) > scopetiming.scope_stop_timepoint;
scope_events_allplanes(deleteevents,:) = [];
% get scope events corresponding to this plane; frames are acquired in order of plane name (iplane) 
if ops1{1}.dobidi % bidirectional
    fprintf('Processing scope timing for bidirectional acquisition...\n')
    scope_events = scope_events_allplanes(iplane:nplanes_in_session_total:end,:); 
elseif ~ops1{1}.dobidi % unidirectional
    go_on = input('Unidirectional acquisition - are you sure? (y=yes) ','s');
    if ~strcmp(go_on,'y')
        error('quitting this function')
    end
    scope_events = scope_events_allplanes(iplane:2*nplanes_in_session_total:end,:);  % skip every other scope event because filler scope events are added for unidirectional acquisition
end
ntrials = height(par_sets);
% % scope_events = scope_events_allplanes_otsquarewave(scope_events_allplanes,iplane); %% comment in this line for rare case of otsquarewave acquisition; order [1 1 2 2], unidirectional assumed

%% find stim events
res.meanImage_pre_rotate = dff_data.meanImage;
res.meanImage_ant_up = rot90(dff_data.meanImage,-1); % rotate so that anterior==up
dFF_matrix = NaN(height(par_sets),size(dff_data.dff,2));
par_sets = [par_sets table(dFF_matrix,dFF_matrix,dFF_matrix,'VariableNames',{'dff_during_stim','dff_during_rspv_window','dff_prestim'})];
scope_events = scope_events(1:nimages,:); % ignore scope events that don't have a corresponding image
scope_events = [scope_events table(dff_data.dff,'VariableNames',{'dff'})];
% for each stim trial, get corresponding scope events
for itrial = 1:ntrials
    % F during stim
    sevents_in_range = find(scope_events.onset>par_sets.stim_onset(itrial) & scope_events.onset<[par_sets.stim_onset(itrial)+stimdur_scans]);
    sevents_in_range = sevents_in_range(1:end-1); % last image duration will be cut off by stim ending
    par_sets.dff_during_stim(itrial,:) = mean(scope_events.dff(sevents_in_range,:));
    % F during stim 'responsivity window'
    sevents_in_range = find(scope_events.onset > par_sets.rspv_window_start(itrial) & scope_events.onset < par_sets.rspv_window_end(itrial));
    par_sets.dff_during_rspv_window(itrial,:) = mean(scope_events.dff(sevents_in_range,:));
    % F during prestim 'baseline window'
    sevents_in_range = find(scope_events.onset > par_sets.baseline_window_start(itrial) & scope_events.onset < par_sets.stim_onset(itrial));
    sevents_in_range = sevents_in_range(1:end-1); % last image duration will be interrupted by stim onset 
    par_sets.dff_prestim(itrial,:) = mean(scope_events.dff(sevents_in_range,:));
end
[res, par_sets] = removeBadFrames(res, par_sets, scope_events, scopetiming, stimdur_scans, baseline_window_scans); % remove bad frames if badframes excel file is present
ntrials = height(par_sets); % update ntrials

%% tuning curves


% get discr index
% better metric for responsivity? should mark all tuned cells as responsive...  
% running modulation
% mean response timecourse with error bars
% check for OFF responses? see F_17203_2018-1-24_plane3_proc_dff_3.mat sftf
%   trials 1-3, cell at 80,253; also cell which is only active before and
%   after stim block 



% get tuning curves
nrois = size(dff_data.dff,2);
for thispar = stimpars_to_analyze
    do_analysis = 0; % default
    thispar = thispar{:};
    initialize_stim_parameter(); 
    if do_analysis
        % for each cell, make table of F response for each trial sorted by stim parameter and trial 
        tuning = table(NaN(nrois,2),false(nrois,1),NaN(nrois,1),false(nrois,1),NaN(nrois,1),cell(nrois,1),cell(nrois,1),NaN(nrois,2),cell(nrois,1),...
            'VariableNames',{'centeryx','sgnf','anovap','sgnf_rspv','anovap_rspv','trials','cellimage_prereg','centeryx_pre_rotate','cellimage_pre_rotate'});
        wbar = waitbar(0,['Getting ' thispar ' tuning curves...']);
        for iroi = 1:nrois 
            if isvalid(wbar)
                waitbar(iroi/nrois,wbar)
            end
            roiimage_pre_rotate = sparse(squeeze(logical(dff_data.masks(iroi,:,:))));
            tuning.cellimage_pre_rotate{iroi} = roiimage_pre_rotate;
            roiimage_prereg = rot90(roiimage_pre_rotate,-1); %%% cell mask after rotating to make anterior point upward
            tuning.cellimage_prereg{iroi} = roiimage_prereg; 
            % get center of mass of cell image - use this location as an identifier for the cell
            [rows, cols] = ndgrid(1:size(roiimage_pre_rotate,1), 1:size(roiimage_pre_rotate,2));
            tuning.centeryx_pre_rotate(iroi,1) = round(sum(sum(rows(roiimage_pre_rotate))) ./ sum(sum(roiimage_pre_rotate))); % y center from top
            tuning.centeryx_pre_rotate(iroi,2) = round(sum(sum(cols(roiimage_pre_rotate))) ./ sum(sum(roiimage_pre_rotate))); % x center from left
            [rows, cols] = ndgrid(1:size(roiimage_prereg,1), 1:size(roiimage_prereg,2));
            tuning.centeryx(iroi,1) = round(sum(sum(rows(roiimage_prereg))) ./ sum(sum(roiimage_prereg))); % y center from top
            tuning.centeryx(iroi,2) = round(sum(sum(cols(roiimage_prereg))) ./ sum(sum(roiimage_prereg))); % x center from left
            % get responses, test for significance
            tuning.trials{iroi} = table(stimparvals,NaN(nparvals,1),NaN(nparvals,pars.repetitions),NaN(nparvals,pars.repetitions),...
                'VariableNames',{thispar,'resp_mean','resp','prestim_base'});
            for indpar = 1:nparvals % get dff values during stim and during prestim window
                match = find(par_sets{:,par_sets_varname}==stimparvals(indpar) & otherparsfixed);
                tuning.trials{iroi}.resp(indpar,1:length(match)) = [par_sets.dff_during_stim(match,iroi)]';
                tuning.trials{iroi}.resp_mean(indpar) = nanmean(tuning.trials{iroi}.resp(indpar,:));
                tuning.trials{iroi}.prestim_base(indpar,1:length(match)) = [par_sets.dff_prestim(match,iroi)]';
            end
            tuning.anovap(iroi) = anova1(tuning.trials{iroi}.resp',[],'off'); % transpose resp so that responses are grouped by stim parameter value
            tuning.sgnf(iroi) = tuning.anovap(iroi) < 0.05;
            %%%% test for responsivity by performing anova on different
            %%%% param vals plus baseline activity
            resp_for_anova = tuning.trials{iroi}.resp'; % transpose so that resps will be extracted in order of param val, not trial number
            resp_for_anova = resp_for_anova(:);
            base_for_anova = tuning.trials{iroi}.prestim_base'; % transpose so that resps will be extracted in order of param val, not trial number
            base_for_anova = base_for_anova(:);
            dff_for_anova = [resp_for_anova; base_for_anova];
            stim_names_for_anova = cellstr(num2str(kron(tuning.trials{iroi}{:,thispar},ones(size(tuning.trials{iroi}.resp,2),1)))); % dummy vars for different stim params
            base_names_for_anova = repmat({'dff_prestim'},length(base_for_anova),1); % dummy vars for base
            combonames_for_anova = [stim_names_for_anova; base_names_for_anova];
            tuning.anovap_rspv(iroi) = anova1(dff_for_anova, combonames_for_anova, 'off'); % get responsiveness anova p value
            tuning.sgnf_rspv(iroi) = tuning.anovap_rspv(iroi) < 0.05;
            % fit functions to tuning curves 
            if fit_tuning_functions
                meanforfit = [stimparvals, tuning.trials{iroi}.resp_mean];
                respforfit = [repmat(stimparvals,pars.repetitions,1), tuning.trials{iroi}.resp(:)];
                respforfit( isnan(respforfit(:,2)),: ) = []; % delete nan trials before fitting
                switch thispar
                    case 'sf'
                        fitparams = SF_loggaussfit(meanforfit,respforfit);
                        tuning.sf_pref(iroi) = fitparams(3); 
                        tuning.sf_fit_base_F(iroi) = fitparams(1);
                        tuning.sf_fit_amp(iroi) = fitparams(2); % amplitude
                        tuning.sf_fit_sigma(iroi) = fitparams(4); % standard deviation
                        tuning.sf_fit_log_offset(iroi) = fitparams(5);
                        tuning.sf_fitparams{iroi} = fitparams;
                        tuning.Properties.UserData = 'sf in cycles per degree';
                        prefval = tuning.sf_pref(iroi);
                        fitfunc = @(q,stimval)q(2).*exp(-1./2./q(4).^2.*(log((stimval+q(5))./(q(3)+q(5)))).^2)+q(1); % lognormal from Gao et al. 2010
                        hwhm_xspacing = 0.0005;
                        hwhm_xmax = 3.5; 
                    case 'tf'
                        fitparams = TF_loggaussfit(meanforfit,respforfit);
                        tuning.tf_pref(iroi) = fitparams(3);
                        tuning.tf_fit_base_F(iroi) = fitparams(1);
                        tuning.tf_fit_amp(iroi) = fitparams(2); % amplitude
                        tuning.tf_fit_sigma(iroi) = fitparams(4); % standard deviation
                        tuning.tf_fit_log_offset(iroi) = fitparams(5);
                        tuning.tf_fitparams{iroi} = fitparams;
                        tuning.Properties.UserData = 'tf in hertz';
                        prefval = tuning.tf_pref(iroi);
                        fitfunc = @(q,stimval)q(2).*exp(-1./2./q(4).^2.*(log((stimval+q(5))./(q(3)+q(5)))).^2)+q(1); % lognormal from Gao et al. 2010
                        hwhm_xspacing = 0.01; 
                        hwhm_xmax = 30;  
                    case 'orient'
                        fitparams = von_mises_fit(meanforfit,respforfit);
                        fitfunc = @(q,stimval)q(1).* exp( q(2).* (cos(stimval.*pi/180-q(3)*pi/180)-1)) + q(4).* exp( q(5).* (cos(stimval.*pi/180-q(6)*pi/180)-1)) + q(7);  % von mises from Gao et al. 2010                    
                        if fitfunc(fitparams,fitparams(3)) < fitfunc(fitparams,fitparams(6)) % if the second pref orient generates higher response than first pref orient, switch their order
                            fitparams = [fitparams(4:6); fitparams(1:3); fitparams(7)]; % put most preferred orient first
                        end
                        tuning.orient_pref1(iroi) = fitparams(3);
                        tuning.orient_amp1(iroi) = fitparams(1);
                        tuning.orient_width1(iroi) = fitparams(2);
                        tuning.orient_pref2(iroi) = fitparams(6);
                        tuning.orient_amp2(iroi) = fitparams(4);
                        tuning.orient_width2(iroi) = fitparams(5);
                        tuning.orient_fit_base_F(iroi) = fitparams(7);
                        tuning.orient_fitparams{iroi} = fitparams;
                        tuning.Properties.UserData = 'orient in degrees';
                        prefval = tuning.orient_pref1(iroi);
                        hwhm_xspacing = 0.1;
                        hwhm_xmax = tuning.orient_pref1(iroi) + 200;
                end
                % search from response peak to hwhm_xmax for the right-side hwhm  
                if prefval >= hwhm_xmax
                    tuning{iroi,[thispar, '_hwhm']} = NaN; % tuning curve is so broad, don't bother computing hwhm
                else
                    tuning{iroi,[thispar, '_hwhm']} = hwhm(fitfunc, fitparams, [prefval  hwhm_xmax], hwhm_xspacing, prefval, tuning{iroi,[thispar,'_fit_base_F']}); 
                end
            end    
        end   
        if isvalid(wbar)
            close(wbar)
        end    

         %%%%% consolidate tuning_tables
        tuning.Properties.VariableNames{strcmp(tuning.Properties.VariableNames,'trials')} = [thispar '_trials']; % rename var
        tuning.Properties.VariableNames{strcmp(tuning.Properties.VariableNames,'anovap')} = [thispar '_anovap']; % rename var
        tuning.Properties.VariableNames{strcmp(tuning.Properties.VariableNames,'anovap_rspv')} = [thispar '_anovap_rsvp']; % rename var
        tuning.Properties.VariableNames{strcmp(tuning.Properties.VariableNames,'sgnf_rspv')} = [thispar  '_sgnf_rspv']; % rename var
        tuning.Properties.VariableNames{strcmp(tuning.Properties.VariableNames,'sgnf')} = [thispar '_sgnf']; % rename var
        if isfield(res,'tuning') % if another stimpar has already been processed
            delvar = [];
            for i = 1:size(tuning,2)
                if iscell(tuning{1,i}) && ~ischar(tuning{1,i}) && any(strcmp(tuning.Properties.VariableNames{i},res.tuning.Properties.VariableNames))
                    delvar = [delvar i];  % non-char cell can't be a key var, so delete
                end
            end
            tuning(:,delvar) = [];
            res.tuning = join(res.tuning,tuning); % join previously processed stimpar with current stimpar in tuning table; keyvars include 'centeryx','rspv','rspv_pval'
        else
            res.tuning = tuning;
        end

        clear tuning stimparvals nparvals par_sets_varname otherparsfixed match
    end
end

%% % determine whether or not cell was responsive to stimuli
responsivity = table(false(nrois,1),NaN(nrois,1),cell(nrois,1),cell(nrois,1),cell(nrois,1),'VariableNames',{'rspv','rspv_pval','preftrials','F_duringwindow','dff_prestim'});
try
    for iroi = 1:nrois
        [~,m] = max(res.tuning.sf_trials{iroi}.resp_mean);
        prefsf = res.tuning.sf_trials{iroi}.sf(m);
        [~,m] = max(res.tuning.tf_trials{iroi}.resp_mean);
        preftf = res.tuning.tf_trials{iroi}.tf(m);
        preftrials = find(par_sets.sfreq==prefsf | par_sets.tfreq==preftf); % find trials when cell saw preferred stimuli
        responsivity.dff_prestim{iroi} = par_sets.dff_prestim(preftrials,iroi);
        responsivity.F_duringwindow{iroi} = par_sets.dff_during_rspv_window(preftrials,iroi);
        [responsivity.rspv(iroi), responsivity.rspv_pval(iroi)] = ttest(responsivity.dff_prestim{iroi}, responsivity.F_duringwindow{iroi});
        responsivity.preftrials{iroi} = preftrials;
    end
end

%% get patch location if patch data is given
if exist('patchdata_file', 'var') && exist('patch_reg_file', 'var') && ~isempty(patchdata_file)
    res = get_roi_patch_location(res, patchdata_file, patch_reg_file);
end

%% get info for each time point
event_data = get_f_behavior_stim(dff_file, abf_file, stimdata_file, scopetiming_file, regops_file);
res.scope_events = event_data.scope_events; 

%% output results
res.tuning.rspv = responsivity.rspv;
res.tuning.rspv_pval = responsivity.rspv_pval;
res.baseline_window_sec = baseline_window_sec;
res.responsivity_window_poststim_sec = responsivity_window_poststim_sec; 
res.responsivity = responsivity;
res.stimpar_sets = par_sets;
res.scopetiming = scopetiming;
res.abf_file = abf_file;
res.regops_file = regops_file;
res.dff_file = dff_file;
res.scopetiming_file = scopetiming_file;
res.stimdata_file = stimdata_file;
        