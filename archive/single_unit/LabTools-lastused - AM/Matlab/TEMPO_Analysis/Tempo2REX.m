function [foo, index, emt, emh, emv, raster1, raster2] = Tempo2REX(data)
% function [foo, index, raster, emt, emh, emv] = Tempo2REX(PATH,FILE)
% This function loads the data structures generated by the LoadTEMPOData program
% and outputs matrices in REX format. 
% i.e. eye movements are represented by time entries (emt)
% Eye position as values corresponding to these entries (emh, emv).  Data are zero padded
% Spike times are represented as time entries (raster1, raster2

	TEMPO_Defs;		%reads in some definitions that we need


 	no_trials = size(data.spike_data,3);
   DArange = data.one_time_params(AD_RANGE)/2;	%Signals from -2048 to +2047
   Hrange = data.one_time_params(X_DEG_FULL_SCALE)/2; %Hor Eye Mov Range from -50 degrees to 50 degrees
   Vrange = data.one_time_params(Y_DEG_FULL_SCALE)/2; %Vert Eye Mov Range from -50 degrees to 50 degrees
   
 %% Process eye data  % speed_units/speed = max rate of sampling.  Divide by 1 + skip to get actual rate
 	hertz = data.htb_header{1}.speed_units / (data.htb_header{1}.speed); %maximum acquisition rate
   binwidth = 1000*(data.htb_header{1}.skip + 1)/hertz; %for eye data, sample acquired every biwidth ms
   no_samples = size(data.eye_data,2);
   
   emt(1:no_samples)=1:binwidth:(binwidth*no_samples);
   for trial = 1:no_trials
       emt(trial,:)=emt(1,:);										% expand times for eye data
   end   
 
   lemh = squeeze(data.eye_data(1,:,:) );
   emh(:,:,1) = lemh';			    
   
   lemv = squeeze(data.eye_data(2,:,:) );
   emv(:,:,1) = lemv';		    
   
	remh = squeeze(data.eye_data(3,:,:) );
   emh(:,:,2) = remh';
    
   remv = squeeze(data.eye_data(4,:,:) );
   emv(:,:,2) = remv';
   
 %% Process spike data
 	hertz = data.htb_header{2}.speed_units / (data.htb_header{2}.speed*(1 + data.htb_header{2}.skip));     
 	no_spikes1 = max(sum(data.spike_data(1,:,:)));
   raster1 = zeros(no_trials,no_spikes1);
   
   % I fixed up this next set of code for transforming database of of spikes per ms bin to rasters of spike times
   % BJP - 3/3/00
   for trial = 1:no_trials
      rastvect = find(data.spike_data(1,:,trial) == 1);
      %might get more than one spike in a single bin when recording multiunit data
      rastvect2 = find(data.spike_data(1,:,trial) == 2);
      rastvect(length(rastvect) + 1: length(rastvect)+length(rastvect2)) = rastvect2;
      %repeat to add spike times in cases where 2 spikes in same bin
      rastvect(length(rastvect) + 1: length(rastvect)+length(rastvect2)) = rastvect2;
		rastvect = sort(rastvect);
      raster1(trial,1:size(rastvect,2)) = rastvect;
      

   end   
   
   if size(data.spike_data,1) == 2
      no_spikes2 = max(sum(data.spike_data(2,:,:)));
		raster2 = zeros(no_trials,no_spikes2);
      for trial = 1:no_trials
           rastvect = find(data.spike_data(1,:,trial));
			  raster2(trial,1:size(rastvect,2)) = rastvect;
      end 
   else 
        raster2 =[];     
   end
      
   
   
%% Generate foo matrix for trial parameters
	hertz = data.htb_header{3}.speed_units / (data.htb_header{3}.speed*(1 + data.htb_header{3}.skip));
   foo = zeros(no_trials, 18);		% Have made space for 18 columns so far
   
   if (data.one_time_params(PROTOCOL) < 200)
      foo(:,1) = (data.dots_params(DOTS_COHER,:,1))'; % c coherence
      foo(:,2) = (data.dots_params(DOTS_DIREC,:,1))'; % c direction 
      foo(:,3) = (sqrt((data.dots_params(DOTS_AP_XSIZ,:,1)).^2 + data.dots_params(DOTS_AP_YSIZ,:,1).^2) )'; % c diameter
      foo(:,4) = (data.dots_params(DOTS_SPEED,:,1))'; % c speed
      foo(:,5) = (data.dots_params(DOTS_HDISP,:,1))'; % c hdisp
      foo(:,6) = (data.targ_params(DOTS_VDISP,:,1))'; % c vdisp
      foo(:,7) = (data.dots_params(DOTS_BIN_CORR,:,1))'; % c bin corr
      
      % surround = patch2
      foo(:,8) = (data.dots_params(DOTS_COHER,:,2))'; % s coh
      foo(:,9) = (data.targ_params(DOTS_DIREC,:,2))'; % s dir
      foo(:,10) = (sqrt((data.dots_params(DOTS_AP_XSIZ,:,2)).^2 + data.dots_params(DOTS_AP_YSIZ,:,2).^2) )'; % s diameter
      foo(:,11) = (data.dots_params(DOTS_SPEED,:,2))'; % s speed
      foo(:,12) = (data.targ_params(DOTS_HDISP,:,2))'; % s hdisp
      foo(:,13) = (data.targ_params(DOTS_VDISP,:,2))'; % s vdisp
      foo(:,14) = (data.dots_params(DOTS_BIN_CORR,:,2))'; % s bin corr
   end
   % more to import have room up to 18 currently
   
%%% Generate index matrix for event times  
   for trial = 1:no_trials
    
      % unfortunately, had to have conditionals to check for the absence of specific events
      event = find(data.event_data(1,:,trial) == 2); % col 1 = FPON
      if isempty(event)
         event = NaN;
      end
      index(trial,1) = event;
      
      event = find(data.event_data(1,:,trial) == 3); % col 2 = IN FIX WINDOW
      if isempty(event)
         event = NaN;
      end
      index(trial,2) = event;
      
      event = find(data.event_data(1,:,trial) == 4); % col 3 = STON
      if isempty(event)
         event = NaN;
      end
      index(trial,3) = event;
      
      event = find(data.event_data(1,:,trial) == 5); % col 4 = STOFF
      if isempty(event)
         event = NaN;
      end     
      index(trial,4) = event;
      
      event = find(data.event_data(1,:,trial) == 6); % col 5 = TRGON
      if isempty(event)
         event = NaN;
      end
      index(trial,5) = event;
      
      %index(trial,6) = find(data.event_data(1,:,trial) == 1
   end
